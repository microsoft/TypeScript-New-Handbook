<!DOCTYPE html>
    <html>
    <head>
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>Handbook Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" type="text/css" media="screen" href="../../css/handbook.css" />
    </head>
    <body>
    <article>
    <!-- Extremely WIP, do not review -->
<h1 id="everyday-types"><a href="#everyday-types">Everyday Types</h1></a>
<p>In this chapter, we'll cover some of the most common types of values you'll find in JavaScript code, and explain the corresponding ways to describe those types in TypeScript.
This isn't an exhaustive list, and future chapters will describe more ways to name and use other types.</p>
<p>Types can also appear in many more <em>places</em> than just type annotations.
As we learn about the types themselves, we'll also learn about the places where we can refer to these types to form new constructs.</p>
<p>We'll start by reviewing the most basic and common types you might encounter when writing JavaScript or TypeScript code.
These will later form the core "building blocks" of more complex types.</p>
<div class="toc"><span class="toc-title">Table of Contents</span><ul><li><a href="#arrays">Arrays</a></li><li><a href="#any"><code>any</code></a></li><ul><li><a href="#noimplicitany"><code>noImplicitAny</code></a></li></ul><li><a href="#type-annotations-on-variables">Type Annotations on Variables</a></li><li><a href="#functions">Functions</a></li><ul><li><a href="#parameter-type-annotations">Parameter Type Annotations</a></li><li><a href="#return-type-annotations">Return Type Annotations</a></li><li><a href="#function-expressions">Function Expressions</a></li></ul><li><a href="#object-types">Object Types</a></li><ul><li><a href="#optional-properties">Optional Properties</a></li></ul><li><a href="#union-types">Union Types</a></li><ul><li><a href="#defining-a-union-type">Defining a Union Type</a></li><li><a href="#working-with-union-types">Working with Union Types</a></li></ul><li><a href="#type-aliases">Type Aliases</a></li><li><a href="#interfaces">Interfaces</a></li><ul><li><a href="#interface-vs-alias">Differences Between Type Aliases and Interfaces</a></li></ul><li><a href="#type-assertions">Type Assertions</a></li><li><a href="#literal-types">Literal Types</a></li><ul><li><a href="#literal-inference">Literal Inference</a></li></ul><li><a href="#null-and-undefined"><code>null</code> and <code>undefined</code></a></li><ul><li><a href="#strictnullchecks-off"><code>strictNullChecks</code> off</a></li><li><a href="#strictnullchecks-on"><code>strictNullChecks</code> on</a></li></ul></ul></ul></div>
<h2 id="primitives-string-number-and-boolean"><a href="#primitives-string-number-and-boolean">Primitives <code>string</code>, <code>number</code>, and <code>boolean</code></h2></a>
<p>JavaScript has three main <a href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive">primitive</a> kinds of values: <code>string</code>, <code>number</code>, and <code>boolean</code>.
Each has a corresponding type in TypeScript.
As you might expect, these are the same names you'd see if you used the JavaScript <code>typeof</code> operator on a value of those types:</p>
<ul>
<li><code>string</code> represents string values like <code>"Hello, world"</code></li>
<li><code>number</code> is for numbers like <code>42</code>. JavaScript does not have a special runtime value for integers, so there's no equivalent to <code>int</code> or <code>float</code> - everything is simply <code>number</code></li>
<li><code>boolean</code> is for the two values <code>true</code> and <code>false</code></li>
</ul>
<blockquote>
  <p>The type names <code>String</code>, <code>Number</code>, and <code>Boolean</code> are legal, but refer to some special built-in types that shouldn't appear in your code. <em>Always</em> use <code>string</code>, <code>number</code>, or <code>boolean</code>.</p>
</blockquote>
<h2 id="arrays"><a href="#arrays">Arrays</h2></a>
<p>To specify the type of an array like <code>[1, 2, 3]</code>, you can use the syntax <code>number[]</code>; this syntax works for any type (e.g. <code>string[]</code> is an array of strings, and so on).
You may also see this written as <code>Array&lt;number&gt;</code>, which means the same thing.
We'll learn more about the syntax <code>T&lt;U&gt;</code> when we cover <em>generics</em>.</p>
<blockquote>
  <p>Note that <code>[number]</code> is a different thing; refer to the section on <em>tuple types</em>.</p>
</blockquote>
<h2 id="any"><a href="#any"><code>any</code></h2></a>
<p>TypeScript also has a special type, <code>any</code>, that you can use whenever you don't want a particular value to cause typechecking errors.</p>
<p>When a value is of type <code>any</code>, you can access any properties of it (which will in turn be of type <code>any</code>), call it like a function, assign it to (or from) a value of any type, or pretty much anything else that's syntactically legal:
<pre class="typescript-code"><span class="keyword">let</span> <span class="identifier">obj</span><span class="punctuation">:</span> <span class="keyword">any</span> <span class="operator">=</span> <span class="punctuation">{</span> <span class="identifier">x</span><span class="punctuation">:</span> <span class="numericLiteral">0</span> <span class="punctuation">}</span><span class="punctuation">;</span>
<span class="comment">// None of these lines of code are errors</span>
<span class="identifier">obj</span><span class="punctuation">.</span><span class="identifier">foo</span><span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">;</span>
<span class="identifier">obj</span><span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">;</span>
<span class="identifier">obj</span><span class="punctuation">.</span><span class="identifier">bar</span> <span class="operator">=</span> <span class="numericLiteral">100</span><span class="punctuation">;</span>
<span class="identifier">obj</span> <span class="operator">=</span> <span class="stringLiteral">"hello"</span><span class="punctuation">;</span>
<span class="keyword">const</span> <span class="identifier">n</span><span class="punctuation">:</span> <span class="keyword">number</span> <span class="operator">=</span> <span class="identifier">obj</span><span class="punctuation">;</span><a class="playground-link" href="https://www.typescriptlang.org/play/#src=let%20obj%3A%20any%20%3D%20%7B%20x%3A%200%20%7D%3B%0A%2F%2F%20None%20of%20these%20lines%20of%20code%20are%20errors%0Aobj.foo()%3B%0Aobj()%3B%0Aobj.bar%20%3D%20100%3B%0Aobj%20%3D%20%22hello%22%3B%0Aconst%20n%3A%20number%20%3D%20obj%3B">Try</a></pre></p>
<p>The <code>any</code> type is useful when you don't want to write out a long type just to convince TypeScript that a particular line of code is okay.</p>
<h3 id="noimplicitany"><a href="#noimplicitany"><code>noImplicitAny</code></h3></a>
<p>When a type isn't specified and can't be inferred from context, TypeScript will typically default to <code>any</code>.
Because <code>any</code> values don't benefit from type-checking, it's usually desirable to avoid these situations.
The compiler flag <code>noImplicitAny</code> will cause any <em>implicit</em> <code>any</code> to be flagged as an error.</p>
<h2 id="type-annotations-on-variables"><a href="#type-annotations-on-variables">Type Annotations on Variables</h2></a>
<p>When you declare a variable using <code>const</code>, <code>var</code>, or <code>let</code>, you can optionally add a type annotation to explicitly specify the type of the variable:
<pre class="typescript-code"><span class="keyword">let</span> <span class="identifier">myName</span><span class="highlight"><span class="highlight-content"></span><span class="highlight-description">Type annotation</span><span class="punctuation">:</span> <span class="keyword">string</span></span> <span class="operator">=</span> <span class="stringLiteral">"Alice"</span><span class="punctuation">;</span></pre></p>
<blockquote>
  <p>TypeScript doesn't use "types on the left"-style declarations like <code>int x = 0;</code>
  Type annotations will always go <em>after</em> the thing being typed.</p>
</blockquote>
<p>In most cases, though, this isn't needed.
Wherever possible, TypeScript tries to automatically <em>infer</em> the types in your code.
For example, the type of a variable is inferred based on the type of its initializer:
<pre class="typescript-code"><span class="comment">// No type annotation needed -- 'myName' inferred as type 'string'</span>
<span class="keyword">let</span> <span class="identifier">myName</span> <span class="operator">=</span> <span class="stringLiteral">"Alice"</span><span class="punctuation">;</span></pre></p>
<p>For the most part you don't need to explicitly learn the rules of inference.
If you're starting out, try using fewer type annotations than you think - you might be surprised how few you need for TypeScript to fully understand what's going on.</p>
<h2 id="functions"><a href="#functions">Functions</h2></a>
<p>Functions are the primary means of passing data around in JavaScript.
TypeScript allows you to specify the types of both the input and output values of functions.</p>
<h3 id="parameter-type-annotations"><a href="#parameter-type-annotations">Parameter Type Annotations</h3></a>
<p>When you declare a function, you can add type annotations after each parameter to declare what kinds of parameters the function accepts.
Parameter type annotations go after the parameter name:</p>
<p><pre class="typescript-code"><span class="comment">// Parameter type annotation</span>
<span class="keyword">function</span> <span class="identifier">greet</span><span class="punctuation">(</span><span class="parameterName">name</span><span class="highlight"><span class="highlight-content"></span><span class="highlight-description"></span><span class="punctuation">:</span> <span class="keyword">string</span></span><span class="punctuation">)</span> <span class="punctuation">{</span>
    <span class="identifier">console</span><span class="punctuation">.</span><span class="identifier">log</span><span class="punctuation">(</span><span class="stringLiteral">"Hello, "</span> <span class="operator">+</span> <span class="identifier">name</span><span class="punctuation">.</span><span class="identifier">toUpperCase</span><span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span> <span class="stringLiteral">"!!"</span><span class="punctuation">)</span><span class="punctuation">;</span>
<span class="punctuation">}</span><a class="playground-link" href="https://www.typescriptlang.org/play/#src=%2F%2F%20Parameter%20type%20annotation%0Afunction%20greet(name%3A%20string)%20%7B%0A%20%20%20%20console.log(%22Hello%2C%20%22%20%2B%20name.toUpperCase()%20%2B%20%22!!%22)%3B%0A%7D">Try</a></pre></p>
<p>When a parameter has a type annotation, calls to that function will be validated:</p>
<p><pre class="typescript-code">
<span class="comment">// Would be a runtime error if executed!</span>
<span class="identifier">greet</span><span class="punctuation">(</span><span class="error"><span class="error-highlight"></span><span class="numericLiteral">42</span></span><span class="punctuation">)</span><span class="punctuation">;</span><hr class="error-divider"><div class="listed-error"><div class="error-line">Argument of type '42' is not assignable to parameter of type 'string'.</div></div></pre></p>
<h3 id="return-type-annotations"><a href="#return-type-annotations">Return Type Annotations</h3></a>
<p>You can also add return type annotations.
Return type annotations appear after the parameter list:</p>
<p><pre class="typescript-code"><span class="keyword">function</span> <span class="identifier">getFavoriteNumber</span><span class="punctuation">(</span><span class="punctuation">)</span><span class="highlight"><span class="highlight-content"></span><span class="highlight-description"></span><span class="punctuation">:</span> <span class="keyword">number</span></span> <span class="punctuation">{</span>
    <span class="keyword">return</span> <span class="numericLiteral">26</span><span class="punctuation">;</span>
<span class="punctuation">}</span><a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20getFavoriteNumber()%3A%20number%20%7B%0A%20%20%20%20return%2026%3B%0A%7D">Try</a></pre></p>
<p>Much like variable type annotations, you usually don't need a return type annotation because TypeScript will infer the function's return type based on its <code>return</code> statements.
The type annotation in the above example doesn't change anything.
Some codebases will explicitly specify a return type for documentation purposes, to prevent accidental changes, or just for personal preference. </p>
<h3 id="function-expressions"><a href="#function-expressions">Function Expressions</h3></a>
<p>Function expressions are a little bit different from function declarations.
When a function expression appears in a place where TypeScript can determine how it's going to be called, the parameters of that function are automatically given types.</p>
<p>Here's an example:</p>
<p><pre class="typescript-code"><span class="comment">// No type annotations here, but TypeScript can spot the bug</span>
<span class="keyword">const</span> <span class="identifier">names</span> <span class="operator">=</span> <span class="punctuation">[</span><span class="stringLiteral">"Alice"</span><span class="punctuation">,</span> <span class="stringLiteral">"Bob"</span><span class="punctuation">,</span> <span class="stringLiteral">"Eve"</span><span class="punctuation">]</span><span class="punctuation">;</span>
<span class="identifier">names</span><span class="punctuation">.</span><span class="identifier">forEach</span><span class="punctuation">(</span><span class="keyword">function</span> <span class="punctuation">(</span><span class="parameterName">s</span><span class="punctuation">)</span> <span class="punctuation">{</span>
    <span class="identifier">console</span><span class="punctuation">.</span><span class="identifier">log</span><span class="punctuation">(</span><span class="identifier">s</span><span class="punctuation">.</span><span class="error"><span class="error-highlight"></span><span class="identifier">toUppercase</span></span><span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">;</span>
<span class="punctuation">}</span><span class="punctuation">)</span><span class="punctuation">;</span><hr class="error-divider"><div class="listed-error"><div class="error-line">Property 'toUppercase' does not exist on type 'string'. Did you mean 'toUpperCase'?</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=%2F%2F%20No%20type%20annotations%20here%2C%20but%20TypeScript%20can%20spot%20the%20bug%0Aconst%20names%20%3D%20%5B%22Alice%22%2C%20%22Bob%22%2C%20%22Eve%22%5D%3B%0Anames.forEach(function%20(s)%20%7B%0A%20%20%20%20console.log(s.toUppercase())%3B%0A%7D)%3B">Try</a></pre></p>
<p>Even though the parameter <code>s</code> didn't have a type annotation, TypeScript used the types of the <code>forEach</code> function, along with the inferred type of the array, to determine the type <code>s</code> will have.</p>
<p>This process is called <em>contextual typing</em> because the <em>context</em> that the function occurred in informed what type it should have.
Similar to the inference rules, you don't need to explicitly learn how this happens, but understanding that it <em>does</em> happen can help you notice when type annotations aren't needed.
Later, we'll see more examples of how the context that a value occurs in can affect its type.</p>
<h2 id="object-types"><a href="#object-types">Object Types</h2></a>
<p>Apart from primitives, the most common sort of type you'll encounter is an <em>object type</em>.
This refers to any JavaScript value with properties, which is almost all of them!
To define an object type, we simply list its properties and their types.</p>
<p>For example, here's a function that takes a point-like object:</p>
<p><pre class="typescript-code"><span class="comment">// The parameter's type annotation is an object type</span>
<span class="keyword">function</span> <span class="identifier">printCoord</span><span class="punctuation">(</span><span class="parameterName">pt</span><span class="punctuation">:</span> <span class="highlight"><span class="highlight-content"></span><span class="highlight-description"></span><span class="punctuation">{</span> <span class="identifier">x</span><span class="punctuation">:</span> <span class="keyword">number</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">:</span> <span class="keyword">number</span> <span class="punctuation">}</span></span><span class="punctuation">)</span> <span class="punctuation">{</span>
  <span class="identifier">console</span><span class="punctuation">.</span><span class="identifier">log</span><span class="punctuation">(</span><span class="stringLiteral">"The coordinate's x value is "</span> <span class="operator">+</span> <span class="identifier">pt</span><span class="punctuation">.</span><span class="identifier">x</span><span class="punctuation">)</span><span class="punctuation">;</span>
  <span class="identifier">console</span><span class="punctuation">.</span><span class="identifier">log</span><span class="punctuation">(</span><span class="stringLiteral">"The coordinate's y value is "</span> <span class="operator">+</span> <span class="identifier">pt</span><span class="punctuation">.</span><span class="identifier">y</span><span class="punctuation">)</span><span class="punctuation">;</span>
<span class="punctuation">}</span>
<span class="identifier">printCoord</span><span class="punctuation">(</span><span class="punctuation">{</span> <span class="identifier">x</span><span class="punctuation">:</span> <span class="numericLiteral">3</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">:</span> <span class="numericLiteral">7</span> <span class="punctuation">}</span><span class="punctuation">)</span><span class="punctuation">;</span><a class="playground-link" href="https://www.typescriptlang.org/play/#src=%2F%2F%20The%20parameter's%20type%20annotation%20is%20an%20object%20type%0Afunction%20printCoord(pt%3A%20%7B%20x%3A%20number%2C%20y%3A%20number%20%7D)%20%7B%0A%20%20console.log(%22The%20coordinate's%20x%20value%20is%20%22%20%2B%20pt.x)%3B%0A%20%20console.log(%22The%20coordinate's%20y%20value%20is%20%22%20%2B%20pt.y)%3B%0A%7D%0AprintCoord(%7B%20x%3A%203%2C%20y%3A%207%20%7D)%3B">Try</a></pre></p>
<p>Here, we annotated the parameter with a type with two properties - <code>x</code> and <code>y</code> - which are both of type <code>number</code>.
You can use <code>,</code> or <code>;</code> to separate the properties, and the last separator is optional either way.</p>
<p>The type part of each property is also optional.
If you don't specify a type, it will be assumed to be <code>any</code>.</p>
<h3 id="optional-properties"><a href="#optional-properties">Optional Properties</h3></a>
<p>Object types can also specify that some or all of their properties are <em>optional</em>.
To do this, add a <code>?</code> after the property name:</p>
<p><pre class="typescript-code"><span class="keyword">function</span> <span class="identifier">printName</span><span class="punctuation">(</span><span class="parameterName">obj</span><span class="punctuation">:</span> <span class="punctuation">{</span> <span class="identifier">first</span><span class="punctuation">:</span> <span class="keyword">string</span><span class="punctuation">,</span> <span class="identifier">last</span><span class="punctuation">?</span><span class="punctuation">:</span> <span class="keyword">string</span><span class="punctuation">}</span><span class="punctuation">)</span> <span class="punctuation">{</span>
  <span class="comment">// ...</span>
<span class="punctuation">}</span>
<span class="comment">// Both OK</span>
<span class="identifier">printName</span><span class="punctuation">(</span><span class="punctuation">{</span> <span class="identifier">first</span><span class="punctuation">:</span> <span class="stringLiteral">"Bob"</span> <span class="punctuation">}</span><span class="punctuation">)</span><span class="punctuation">;</span>
<span class="identifier">printName</span><span class="punctuation">(</span><span class="punctuation">{</span> <span class="identifier">first</span><span class="punctuation">:</span> <span class="stringLiteral">"Alice"</span><span class="punctuation">,</span> <span class="identifier">last</span><span class="punctuation">:</span> <span class="stringLiteral">"Alisson"</span> <span class="punctuation">}</span><span class="punctuation">)</span><span class="punctuation">;</span><a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20printName(obj%3A%20%7B%20first%3A%20string%2C%20last%3F%3A%20string%7D)%20%7B%0A%20%20%2F%2F%20...%0A%7D%0A%2F%2F%20Both%20OK%0AprintName(%7B%20first%3A%20%22Bob%22%20%7D)%3B%0AprintName(%7B%20first%3A%20%22Alice%22%2C%20last%3A%20%22Alisson%22%20%7D)%3B">Try</a></pre></p>
<p>In JavaScript, if you access a property that doesn't exist, you'll get the value <code>undefined</code> rather than a runtime error.
Because of this, when you <em>read</em> from an optional property, you'll have to check for <code>undefined</code> before using it.</p>
<p><pre class="typescript-code"><span class="keyword">function</span> <span class="identifier">printName</span><span class="punctuation">(</span><span class="parameterName">obj</span><span class="punctuation">:</span> <span class="punctuation">{</span> <span class="identifier">first</span><span class="punctuation">:</span> <span class="keyword">string</span><span class="punctuation">,</span> <span class="identifier">last</span><span class="punctuation">?</span><span class="punctuation">:</span> <span class="keyword">string</span><span class="punctuation">}</span><span class="punctuation">)</span> <span class="punctuation">{</span>
  <span class="comment">// Error - might crash if 'obj.last' wasn't provided!</span>
  <span class="identifier">console</span><span class="punctuation">.</span><span class="identifier">log</span><span class="punctuation">(</span><span class="error"><span class="error-highlight"></span><span class="identifier">obj</span><span class="punctuation">.</span><span class="identifier">last</span></span><span class="punctuation">.</span><span class="identifier">toUpperCase</span><span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">;</span>
  <span class="keyword">if</span> <span class="punctuation">(</span><span class="identifier">obj</span><span class="punctuation">.</span><span class="identifier">last</span> <span class="operator">!==</span> <span class="identifier">undefined</span><span class="punctuation">)</span> <span class="punctuation">{</span>
    <span class="comment">// OK</span>
    <span class="identifier">console</span><span class="punctuation">.</span><span class="identifier">log</span><span class="punctuation">(</span><span class="identifier">obj</span><span class="punctuation">.</span><span class="identifier">last</span><span class="punctuation">.</span><span class="identifier">toUpperCase</span><span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">;</span>
  <span class="punctuation">}</span>
<span class="punctuation">}</span><hr class="error-divider"><div class="listed-error"><div class="error-line">Object is possibly 'undefined'.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20printName(obj%3A%20%7B%20first%3A%20string%2C%20last%3F%3A%20string%7D)%20%7B%0A%20%20%2F%2F%20Error%20-%20might%20crash%20if%20'obj.last'%20wasn't%20provided!%0A%20%20console.log(obj.last.toUpperCase())%3B%0A%20%20if%20(obj.last%20!%3D%3D%20undefined)%20%7B%0A%20%20%20%20%2F%2F%20OK%0A%20%20%20%20console.log(obj.last.toUpperCase())%3B%0A%20%20%7D%0A%7D">Try</a></pre></p>
<h2 id="union-types"><a href="#union-types">Union Types</h2></a>
<p>TypeScript's type system allows you to build new types out of existing ones using a large variety of operators.
Now that we know how to write a few types, it's time to start <em>combining</em> them in interesting ways.</p>
<h3 id="defining-a-union-type"><a href="#defining-a-union-type">Defining a Union Type</h3></a>
<p>The first way to combine types you might see is a <em>union</em> type.
A union type is type formed from two or more other types, representing values that may be <em>any one</em> of those types.
We refer to each of these types as the union's <em>members</em>.</p>
<p>Let's write a function that can operate on strings or numbers:
<pre class="typescript-code"><span class="keyword">function</span> <span class="identifier">printId</span><span class="punctuation">(</span><span class="parameterName">id</span><span class="punctuation">:</span> <span class="keyword">number</span> <span class="punctuation">|</span> <span class="keyword">string</span><span class="punctuation">)</span> <span class="punctuation">{</span>
  <span class="identifier">console</span><span class="punctuation">.</span><span class="identifier">log</span><span class="punctuation">(</span><span class="stringLiteral">"Your ID is: "</span> <span class="operator">+</span> <span class="identifier">id</span><span class="punctuation">)</span><span class="punctuation">;</span>
<span class="punctuation">}</span>
<span class="comment">// OK</span>
<span class="identifier">printId</span><span class="punctuation">(</span><span class="numericLiteral">101</span><span class="punctuation">)</span><span class="punctuation">;</span>
<span class="comment">// OK</span>
<span class="identifier">printId</span><span class="punctuation">(</span><span class="stringLiteral">"202"</span><span class="punctuation">)</span><span class="punctuation">;</span>
<span class="comment">// Error</span>
<span class="identifier">printId</span><span class="punctuation">(</span><span class="error"><span class="error-highlight"></span><span class="punctuation">[</span><span class="numericLiteral">1</span><span class="punctuation">,</span> <span class="numericLiteral">2</span><span class="punctuation">]</span></span><span class="punctuation">)</span><span class="punctuation">;</span><hr class="error-divider"><div class="listed-error"><div class="error-line">Argument of type 'number[]' is not assignable to parameter of type 'string | number'.</div><div class="error-line"><div class="indent"></div>Type 'number[]' is not assignable to type 'string'.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20printId(id%3A%20number%20%7C%20string)%20%7B%0A%20%20console.log(%22Your%20ID%20is%3A%20%22%20%2B%20id)%3B%0A%7D%0A%2F%2F%20OK%0AprintId(101)%3B%0A%2F%2F%20OK%0AprintId(%22202%22)%3B%0A%2F%2F%20Error%0AprintId(%5B1%2C%202%5D)%3B">Try</a></pre></p>
<h3 id="working-with-union-types"><a href="#working-with-union-types">Working with Union Types</h3></a>
<p>It's easy to <em>provide</em> a value matching a union type - simply provide a type matching any of the union's members.
If you <em>have</em> a value of a union type, how do you work with it?</p>
<p>TypeScript will only allow you to do things with the union if that thing is valid for <em>every</em> member of the union.
For example, if you have the union <code>string | number</code>, you can't use methods that are only available on <code>string</code>:
<pre class="typescript-code"><span class="keyword">function</span> <span class="identifier">printId</span><span class="punctuation">(</span><span class="parameterName">id</span><span class="punctuation">:</span> <span class="keyword">number</span> <span class="punctuation">|</span> <span class="keyword">string</span><span class="punctuation">)</span> <span class="punctuation">{</span>
  <span class="identifier">console</span><span class="punctuation">.</span><span class="identifier">log</span><span class="punctuation">(</span><span class="identifier">id</span><span class="punctuation">.</span><span class="error"><span class="error-highlight"></span><span class="identifier">toUpperCase</span></span><span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">;</span>
<span class="punctuation">}</span><hr class="error-divider"><div class="listed-error"><div class="error-line">Property 'toUpperCase' does not exist on type 'string | number'.</div><div class="error-line"><div class="indent"></div>Property 'toUpperCase' does not exist on type 'number'.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20printId(id%3A%20number%20%7C%20string)%20%7B%0A%20%20console.log(id.toUpperCase())%3B%0A%7D">Try</a></pre></p>
<p>The solution is to <em>narrow</em> the union with code, the same as you would in JavaScript without type annotations.
<em>Narrowing</em> occurs when TypeScript can deduce a more specific type for a value based on the structure of the code.</p>
<p>For example, TypeScript knows that only a <code>string</code> value will have a <code>typeof</code> value <code>"string"</code>:
<pre class="typescript-code"><span class="keyword">function</span> <span class="identifier">printId</span><span class="punctuation">(</span><span class="parameterName">id</span><span class="punctuation">:</span> <span class="keyword">number</span> <span class="punctuation">|</span> <span class="keyword">string</span><span class="punctuation">)</span> <span class="punctuation">{</span>
  <span class="keyword">if</span> <span class="punctuation">(</span><span class="keyword">typeof</span> <span class="identifier">id</span> <span class="operator">===</span> <span class="stringLiteral">"string"</span><span class="punctuation">)</span> <span class="punctuation">{</span>
    <span class="comment">// In this branch, id is of type 'string'</span>
    <span class="identifier">console</span><span class="punctuation">.</span><span class="identifier">log</span><span class="punctuation">(</span><span class="identifier">id</span><span class="punctuation">.</span><span class="identifier">toUpperCase</span><span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">;</span>
  <span class="punctuation">}</span> <span class="keyword">else</span> <span class="punctuation">{</span>
    <span class="comment">// Here, id is of type 'number'</span>
    <span class="identifier">console</span><span class="punctuation">.</span><span class="identifier">log</span><span class="punctuation">(</span><span class="identifier">id</span><span class="punctuation">)</span><span class="punctuation">;</span>
  <span class="punctuation">}</span>
<span class="punctuation">}</span><a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20printId(id%3A%20number%20%7C%20string)%20%7B%0A%20%20if%20(typeof%20id%20%3D%3D%3D%20%22string%22)%20%7B%0A%20%20%20%20%2F%2F%20In%20this%20branch%2C%20id%20is%20of%20type%20'string'%0A%20%20%20%20console.log(id.toUpperCase())%3B%0A%20%20%7D%20else%20%7B%0A%20%20%20%20%2F%2F%20Here%2C%20id%20is%20of%20type%20'number'%0A%20%20%20%20console.log(id)%3B%0A%20%20%7D%0A%7D">Try</a></pre></p>
<p>Another example is to use a function like <code>Array.isArray</code>:
<pre class="typescript-code"><span class="keyword">function</span> <span class="identifier">welcomePeople</span><span class="punctuation">(</span><span class="parameterName">x</span><span class="punctuation">:</span> <span class="keyword">string</span><span class="punctuation">[</span><span class="punctuation">]</span> <span class="punctuation">|</span> <span class="keyword">string</span><span class="punctuation">)</span> <span class="punctuation">{</span>
  <span class="keyword">if</span> <span class="punctuation">(</span><span class="identifier">Array</span><span class="punctuation">.</span><span class="identifier">isArray</span><span class="punctuation">(</span><span class="identifier">x</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="punctuation">{</span>
    <span class="comment">// Here: 'x' is 'string[]'</span>
    <span class="identifier">console</span><span class="punctuation">.</span><span class="identifier">log</span><span class="punctuation">(</span><span class="stringLiteral">"Hello, "</span> <span class="operator">+</span> <span class="identifier">x</span><span class="punctuation">.</span><span class="identifier">join</span><span class="punctuation">(</span><span class="stringLiteral">" and "</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">;</span>
  <span class="punctuation">}</span> <span class="keyword">else</span> <span class="punctuation">{</span>
    <span class="comment">// Here: 'x' is 'string'</span>
    <span class="identifier">console</span><span class="punctuation">.</span><span class="identifier">log</span><span class="punctuation">(</span><span class="stringLiteral">"Welcome lone traveler "</span> <span class="operator">+</span> <span class="identifier">x</span><span class="punctuation">)</span><span class="punctuation">;</span>
  <span class="punctuation">}</span>
<span class="punctuation">}</span><a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20welcomePeople(x%3A%20string%5B%5D%20%7C%20string)%20%7B%0A%20%20if%20(Array.isArray(x))%20%7B%0A%20%20%20%20%2F%2F%20Here%3A%20'x'%20is%20'string%5B%5D'%0A%20%20%20%20console.log(%22Hello%2C%20%22%20%2B%20x.join(%22%20and%20%22))%3B%0A%20%20%7D%20else%20%7B%0A%20%20%20%20%2F%2F%20Here%3A%20'x'%20is%20'string'%0A%20%20%20%20console.log(%22Welcome%20lone%20traveler%20%22%20%2B%20x)%3B%0A%20%20%7D%0A%7D">Try</a></pre>
Notice that in the <code>else</code> branch, we don't need to do anything special - if <code>x</code> wasn't a <code>string[]</code>, then it must have been a <code>string</code>.</p>
<p>Sometimes you'll have a union where all the members have something in common.
For example, both arrays and strings have a <code>slice</code> method.
If every member in a union has a property in common, you can use that property without narrowing:
<pre class="typescript-code"><span class="comment">// Return type is inferred as number[] | string</span>
<span class="keyword">function</span> <span class="identifier">getFirstThree</span><span class="punctuation">(</span><span class="parameterName">x</span><span class="punctuation">:</span> <span class="keyword">number</span><span class="punctuation">[</span><span class="punctuation">]</span> <span class="punctuation">|</span> <span class="keyword">string</span><span class="punctuation">)</span> <span class="punctuation">{</span>
  <span class="keyword">return</span> <span class="identifier">x</span><span class="punctuation">.</span><span class="identifier">slice</span><span class="punctuation">(</span><span class="numericLiteral">0</span><span class="punctuation">,</span> <span class="numericLiteral">3</span><span class="punctuation">)</span><span class="punctuation">;</span>
<span class="punctuation">}</span><a class="playground-link" href="https://www.typescriptlang.org/play/#src=%2F%2F%20Return%20type%20is%20inferred%20as%20number%5B%5D%20%7C%20string%0Afunction%20getFirstThree(x%3A%20number%5B%5D%20%7C%20string)%20%7B%0A%20%20return%20x.slice(0%2C%203)%3B%0A%7D">Try</a></pre></p>
<blockquote>
  <p>It might be confusing that a <em>union</em> of types appears to have the <em>intersection</em> of those types' properties.
  This is not an accident - the name <em>union</em> comes from type theory.
  The <em>union</em> <code>number | string</code> is composed by taking the union <em>of the values</em> from each type.
  Notice that given two sets with corresponding facts about each set, only the <em>intersection</em> of those facts applies to the <em>union</em> of the sets themselves.
  For example, if we had a room of tall people wearing hats, and another room of Spanish speakers wearings hats, after combining those rooms, the only thing we know about <em>every</em> person is that they must be wearing a hat.</p>
</blockquote>
<h2 id="type-aliases"><a href="#type-aliases">Type Aliases</h2></a>
<p>We've been using object types and union types by writing them directly in type annotations.
This is convenient, but it's common to want to use the same type more than once and refer to it by a single name.</p>
<p>A <em>type alias</em> is exactly that - a <em>name</em> for any <em>type</em>.
The syntax for a type alias is:</p>
<p><pre class="typescript-code"><span class="keyword">type</span> <span class="typeAliasName"><span class="identifier">Point</span></span> <span class="punctuation">=</span> <span class="punctuation">{</span>
  <span class="identifier">x</span><span class="punctuation">:</span> <span class="keyword">number</span><span class="punctuation">,</span>
  <span class="identifier">y</span><span class="punctuation">:</span> <span class="keyword">number</span>
<span class="punctuation">}</span><span class="punctuation">;</span>

<span class="comment">// Exactly the same as the earlier example</span>
<span class="keyword">function</span> <span class="identifier">printCoord</span><span class="punctuation">(</span><span class="parameterName">pt</span><span class="punctuation">:</span> <span class="typeAliasName"><span class="identifier">Point</span></span><span class="punctuation">)</span> <span class="punctuation">{</span>
  <span class="identifier">console</span><span class="punctuation">.</span><span class="identifier">log</span><span class="punctuation">(</span><span class="stringLiteral">"The coordinate's x value is "</span> <span class="operator">+</span> <span class="identifier">pt</span><span class="punctuation">.</span><span class="identifier">x</span><span class="punctuation">)</span><span class="punctuation">;</span>
  <span class="identifier">console</span><span class="punctuation">.</span><span class="identifier">log</span><span class="punctuation">(</span><span class="stringLiteral">"The coordinate's y value is "</span> <span class="operator">+</span> <span class="identifier">pt</span><span class="punctuation">.</span><span class="identifier">y</span><span class="punctuation">)</span><span class="punctuation">;</span>
<span class="punctuation">}</span><a class="playground-link" href="https://www.typescriptlang.org/play/#src=type%20Point%20%3D%20%7B%0A%20%20x%3A%20number%2C%0A%20%20y%3A%20number%0A%7D%3B%0A%0A%2F%2F%20Exactly%20the%20same%20as%20the%20earlier%20example%0Afunction%20printCoord(pt%3A%20Point)%20%7B%0A%20%20console.log(%22The%20coordinate's%20x%20value%20is%20%22%20%2B%20pt.x)%3B%0A%20%20console.log(%22The%20coordinate's%20y%20value%20is%20%22%20%2B%20pt.y)%3B%0A%7D">Try</a></pre></p>
<p>You can actually use a type alias to give a name to any type at all, not just an object type.
For example, a type alias can name a union type:</p>
<p><pre class="typescript-code"><span class="keyword">type</span> <span class="typeAliasName"><span class="identifier">ID</span></span> <span class="punctuation">=</span> <span class="keyword">number</span> <span class="punctuation">|</span> <span class="keyword">string</span><span class="punctuation">;</span></pre></p>
<p>Note that aliases are <em>only</em> aliases - you cannot use type aliases to create different/distinct "versions" of the same type.
When you use the alias, it's exactly as if you had written the aliased type.
In other words, this code might <em>look</em> illegal, but is OK according to TypeScript because both types are aliases for the same type:</p>
<p><pre class="typescript-code"><span class="keyword">type</span> <span class="typeAliasName"><span class="identifier">Age</span></span> <span class="punctuation">=</span> <span class="keyword">number</span><span class="punctuation">;</span>
<span class="keyword">type</span> <span class="typeAliasName"><span class="identifier">Weight</span></span> <span class="punctuation">=</span> <span class="keyword">number</span><span class="punctuation">;</span>

<span class="keyword">const</span> <span class="identifier">myAge</span><span class="punctuation">:</span> <span class="typeAliasName"><span class="identifier">Age</span></span> <span class="operator">=</span> <span class="numericLiteral">73</span><span class="punctuation">;</span>
<span class="comment">// *not* an error</span>
<span class="keyword">const</span> <span class="identifier">myWeight</span><span class="punctuation">:</span> <span class="typeAliasName"><span class="identifier">Weight</span></span> <span class="operator">=</span> <span class="identifier">myAge</span><span class="punctuation">;</span><a class="playground-link" href="https://www.typescriptlang.org/play/#src=type%20Age%20%3D%20number%3B%0Atype%20Weight%20%3D%20number%3B%0A%0Aconst%20myAge%3A%20Age%20%3D%2073%3B%0A%2F%2F%20*not*%20an%20error%0Aconst%20myWeight%3A%20Weight%20%3D%20myAge%3B">Try</a></pre></p>
<h2 id="interfaces"><a href="#interfaces">Interfaces</h2></a>
<p>An <em>interface declaration</em> is another way to name an object type:
<pre class="typescript-code"><span class="keyword">interface</span> <span class="interfaceName"><span class="interfaceName">Point</span></span> <span class="punctuation">{</span>
  <span class="identifier">x</span><span class="punctuation">:</span> <span class="keyword">number</span><span class="punctuation">;</span>
  <span class="identifier">y</span><span class="punctuation">:</span> <span class="keyword">number</span><span class="punctuation">;</span>
<span class="punctuation">}</span><a class="playground-link" href="https://www.typescriptlang.org/play/#src=interface%20Point%20%7B%0A%20%20x%3A%20number%3B%0A%20%20y%3A%20number%3B%0A%7D">Try</a></pre></p>
<h3 id="interface-vs-alias"><a href="#interface-vs-alias">Differences Between Type Aliases and Interfaces</h3></a>
<p>Type aliases and interfaces are very similar, and in many cases you can choose between them freely.
Here are the most relevant differences between the two that you should be aware of.
You'll learn more about these concepts in later chapters, so don't worry if you don't understand all of these right away.</p>
<ul>
<li>Interfaces may be <code>extend</code>ed, but not type aliases. We'll discuss this later, but it means that interfaces can provide more guarantees when creating new types out of other types.</li>
<li>Type aliases may not participate in declaration merging, but interfaces can.</li>
<li>Interfaces may only be used to declare object types.</li>
<li>Interface names will <em>always</em> appear in their original form in error messages, but <em>only</em> when they are used by name.</li>
<li>Type alias names <em>may</em> appear in error messages, sometimes in place of the equivalent anonymous type (which may or may not be desirable).</li>
</ul>
<p>For the most part, you can choose based on personal preference, and TypeScript will tell you if it needs something to be the other kind of declaration.</p>
<h2 id="type-assertions"><a href="#type-assertions">Type Assertions</h2></a>
<p>Sometimes you will have information about the type of a value that TypeScript can't know about.</p>
<p>For example, if you're using <code>document.getElementById</code>, TypeScript only knows that this will return <em>some</em> kind of <code>HTMLElement</code>, but you might know that your page will always have an <code>HTMLCanvasElement</code> with a given ID.</p>
<p>In this situation, you can use a <em>type assertion</em> to specify a more specific type:</p>
<p><pre class="typescript-code"><span class="keyword">const</span> <span class="identifier">myCanvas</span> <span class="operator">=</span> <span class="identifier">document</span><span class="punctuation">.</span><span class="identifier">getElementById</span><span class="punctuation">(</span><span class="stringLiteral">"main_canvas"</span><span class="punctuation">)</span> <span class="keyword">as</span> <span class="interfaceName"><span class="identifier">HTMLCanvasElement</span></span><span class="punctuation">;</span></pre></p>
<p>Like a type annotation, type assertions are removed by the compiler and won't affect the runtime behavior of your code.</p>
<p>You can also use the angle-bracket syntax (except if the code is in a <code>.tsx</code> file), which is equivalent:</p>
<p><pre class="typescript-code"><span class="keyword">const</span> <span class="identifier">myCanvas</span> <span class="operator">=</span> <span class="punctuation"><</span><span class="interfaceName"><span class="identifier">HTMLCanvasElement</span></span><span class="punctuation">></span><span class="identifier">document</span><span class="punctuation">.</span><span class="identifier">getElementById</span><span class="punctuation">(</span><span class="stringLiteral">"main_canvas"</span><span class="punctuation">)</span><span class="punctuation">;</span></pre></p>
<blockquote>
  <p>Reminder: Because they are removed at compile-time, there is no runtime checking associated with a type assertion.
  There won't be an exception or <code>null</code> generated if the type assertion is wrong.</p>
</blockquote>
<p>TypeScript only allows type assertions which convert to a <em>more specific</em> or <em>less specific</em> version of a type.
This rule prevents "impossible" coercions like:</p>
<p><pre class="typescript-code"><span class="keyword">const</span> <span class="identifier">x</span> <span class="operator">=</span> <span class="error"><span class="error-highlight"></span><span class="stringLiteral">"hello"</span> <span class="keyword">as</span> <span class="keyword">number</span></span><span class="punctuation">;</span><hr class="error-divider"><div class="listed-error"><div class="error-line">Conversion of type 'string' to type 'number' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.</div></div></pre></p>
<p>Sometimes this rule can be too conservative and will disallow more complex coercions that might be valid.
If this happens, you can use two assertions, first to <code>any</code> (or <code>unknown</code>, which we'll introduce later), then to the desired type:
<pre class="typescript-code">
<span class="keyword">const</span> <span class="identifier">a</span> <span class="operator">=</span> <span class="identifier">expr</span> <span class="keyword">as</span> <span class="keyword">any</span> <span class="keyword">as</span> <span class="typeAliasName"><span class="identifier">T</span></span><span class="punctuation">;</span></pre></p>
<h2 id="literal-types"><a href="#literal-types">Literal Types</h2></a>
<p>In addition to the general types <code>string</code> and <code>number</code>, we can refer to <em>specific</em> strings and numbers in type positions.</p>
<p>By themselves, literal types aren't very valuable:</p>
<p><pre class="typescript-code"><span class="keyword">let</span> <span class="identifier">x</span><span class="punctuation">:</span> <span class="stringLiteral">"hello"</span> <span class="operator">=</span> <span class="stringLiteral">"hello"</span><span class="punctuation">;</span>
<span class="comment">// OK</span>
<span class="identifier">x</span> <span class="operator">=</span> <span class="stringLiteral">"hello"</span><span class="punctuation">;</span>
<span class="comment">// OK</span>
<span class="identifier">x</span> <span class="operator">=</span> <span class="stringLiteral">"hello"</span><span class="punctuation">;</span>
<span class="comment">// ...</span>
<span class="error"><span class="error-highlight"></span><span class="identifier">x</span></span> <span class="operator">=</span> <span class="stringLiteral">"howdy"</span><span class="punctuation">;</span><hr class="error-divider"><div class="listed-error"><div class="error-line">Type '"howdy"' is not assignable to type '"hello"'.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=let%20x%3A%20%22hello%22%20%3D%20%22hello%22%3B%0A%2F%2F%20OK%0Ax%20%3D%20%22hello%22%3B%0A%2F%2F%20OK%0Ax%20%3D%20%22hello%22%3B%0A%2F%2F%20...%0Ax%20%3D%20%22howdy%22%3B">Try</a></pre></p>
<p>It's not much use to have a variable that can only have one value!</p>
<p>But by <em>combining</em> literals into unions, you can express a much more useful thing - for example, functions that only accept a certain set of known values:</p>
<p><pre class="typescript-code"><span class="keyword">function</span> <span class="identifier">printText</span><span class="punctuation">(</span><span class="parameterName">s</span><span class="punctuation">:</span> <span class="keyword">string</span><span class="punctuation">,</span> <span class="parameterName">alignment</span><span class="punctuation">:</span> <span class="stringLiteral">"left"</span> <span class="punctuation">|</span> <span class="stringLiteral">"right"</span> <span class="punctuation">|</span> <span class="stringLiteral">"center"</span><span class="punctuation">)</span> <span class="punctuation">{</span>
  <span class="comment">// ...</span>
<span class="punctuation">}</span>
<span class="identifier">printText</span><span class="punctuation">(</span><span class="stringLiteral">"Hello, world"</span><span class="punctuation">,</span> <span class="stringLiteral">"left"</span><span class="punctuation">)</span><span class="punctuation">;</span>
<span class="identifier">printText</span><span class="punctuation">(</span><span class="stringLiteral">"G'day, mate"</span><span class="punctuation">,</span> <span class="error"><span class="error-highlight"></span><span class="stringLiteral">"centre"</span></span><span class="punctuation">)</span><span class="punctuation">;</span><hr class="error-divider"><div class="listed-error"><div class="error-line">Argument of type '"centre"' is not assignable to parameter of type '"left" | "right" | "center"'.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20printText(s%3A%20string%2C%20alignment%3A%20%22left%22%20%7C%20%22right%22%20%7C%20%22center%22)%20%7B%0A%20%20%2F%2F%20...%0A%7D%0AprintText(%22Hello%2C%20world%22%2C%20%22left%22)%3B%0AprintText(%22G'day%2C%20mate%22%2C%20%22centre%22)%3B">Try</a></pre></p>
<p>Numeric literal types work the same way:</p>
<p><pre class="typescript-code"><span class="keyword">function</span> <span class="identifier">compare</span><span class="punctuation">(</span><span class="parameterName">a</span><span class="punctuation">:</span> <span class="keyword">string</span><span class="punctuation">,</span> <span class="parameterName">b</span><span class="punctuation">:</span> <span class="keyword">string</span><span class="punctuation">)</span><span class="punctuation">:</span> <span class="operator">-</span><span class="numericLiteral">1</span> <span class="punctuation">|</span> <span class="numericLiteral">0</span> <span class="punctuation">|</span> <span class="numericLiteral">1</span> <span class="punctuation">{</span>
  <span class="keyword">return</span> <span class="identifier">a</span> <span class="operator">===</span> <span class="identifier">b</span> <span class="operator">?</span> <span class="numericLiteral">0</span> <span class="operator">:</span> <span class="identifier">a</span> <span class="operator">></span> <span class="identifier">b</span> <span class="operator">?</span> <span class="numericLiteral">1</span> <span class="operator">:</span> <span class="operator">-</span><span class="numericLiteral">1</span><span class="punctuation">;</span>
<span class="punctuation">}</span><a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20compare(a%3A%20string%2C%20b%3A%20string)%3A%20-1%20%7C%200%20%7C%201%20%7B%0A%20%20return%20a%20%3D%3D%3D%20b%20%3F%200%20%3A%20a%20%3E%20b%20%3F%201%20%3A%20-1%3B%0A%7D">Try</a></pre></p>
<p>Of course, you can combine these with non-literal types:</p>
<p><pre class="typescript-code"><span class="keyword">interface</span> <span class="interfaceName"><span class="interfaceName">Options</span></span> <span class="punctuation">{</span>
  <span class="identifier">width</span><span class="punctuation">:</span> <span class="keyword">number</span><span class="punctuation">;</span>
<span class="punctuation">}</span>
<span class="keyword">function</span> <span class="identifier">configure</span><span class="punctuation">(</span><span class="parameterName">x</span><span class="punctuation">:</span> <span class="interfaceName"><span class="identifier">Options</span></span> <span class="punctuation">|</span> <span class="stringLiteral">"auto"</span><span class="punctuation">)</span> <span class="punctuation">{</span>
  <span class="comment">// ...</span>
<span class="punctuation">}</span>
<span class="identifier">configure</span><span class="punctuation">(</span><span class="punctuation">{</span> <span class="identifier">width</span><span class="punctuation">:</span> <span class="numericLiteral">100</span> <span class="punctuation">}</span><span class="punctuation">)</span><span class="punctuation">;</span>
<span class="identifier">configure</span><span class="punctuation">(</span><span class="stringLiteral">"auto"</span><span class="punctuation">)</span><span class="punctuation">;</span>
<span class="identifier">configure</span><span class="punctuation">(</span><span class="error"><span class="error-highlight"></span><span class="stringLiteral">"otto"</span></span><span class="punctuation">)</span><span class="punctuation">;</span><hr class="error-divider"><div class="listed-error"><div class="error-line">Argument of type '"otto"' is not assignable to parameter of type 'Options | "auto"'.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=interface%20Options%20%7B%0A%20%20width%3A%20number%3B%0A%7D%0Afunction%20configure(x%3A%20Options%20%7C%20%22auto%22)%20%7B%0A%20%20%2F%2F%20...%0A%7D%0Aconfigure(%7B%20width%3A%20100%20%7D)%3B%0Aconfigure(%22auto%22)%3B%0Aconfigure(%22otto%22)%3B">Try</a></pre></p>
<p>There's one more kind of literal type: boolean literals.
There are only two boolean literal types, and as you might guess, they are the types <code>true</code> and <code>false</code>.
The type <code>boolean</code> itself is actually just an alias for the union <code>true | false</code>.</p>
<h3 id="literal-inference"><a href="#literal-inference">Literal Inference</h3></a>
<p>When you initialize a variable with an object, TypeScript assumes that the properties of that object might change values later.
For example, if you wrote code like this:
<pre class="typescript-code">
<span class="keyword">const</span> <span class="identifier">obj</span> <span class="operator">=</span> <span class="punctuation">{</span> <span class="identifier">counter</span><span class="punctuation">:</span> <span class="numericLiteral">0</span> <span class="punctuation">}</span><span class="punctuation">;</span>
<span class="keyword">if</span> <span class="punctuation">(</span><span class="identifier">someCondition</span><span class="punctuation">)</span> <span class="punctuation">{</span>
  <span class="identifier">obj</span><span class="punctuation">.</span><span class="identifier">counter</span> <span class="operator">=</span> <span class="numericLiteral">1</span><span class="punctuation">;</span>
<span class="punctuation">}</span><a class="playground-link" href="https://www.typescriptlang.org/play/#src=declare%20const%20someCondition%3A%20boolean%3B%0A%2F%2Fcut%0Aconst%20obj%20%3D%20%7B%20counter%3A%200%20%7D%3B%0Aif%20(someCondition)%20%7B%0A%20%20obj.counter%20%3D%201%3B%0A%7D">Try</a></pre>
TypeScript doesn't assume the assignment of <code>1</code> to a field that previously had <code>0</code> to be an error.
Another way of saying this is that <code>obj.counter</code> must have the type <code>number</code>, not <code>0</code>, because types are used to determine both <em>reading</em> and <em>writing</em> behavior.</p>
<p>The same applies to strings:</p>
<p><pre class="typescript-code">
<span class="keyword">const</span> <span class="identifier">req</span> <span class="operator">=</span> <span class="punctuation">{</span> <span class="identifier">url</span><span class="punctuation">:</span> <span class="stringLiteral">"https://example.com"</span><span class="punctuation">,</span> <span class="identifier">method</span><span class="punctuation">:</span> <span class="stringLiteral">"GET"</span> <span class="punctuation">}</span><span class="punctuation">;</span>
<span class="identifier">handleRequest</span><span class="punctuation">(</span><span class="identifier">req</span><span class="punctuation">.</span><span class="identifier">url</span><span class="punctuation">,</span> <span class="error"><span class="error-highlight"></span><span class="identifier">req</span><span class="punctuation">.</span><span class="identifier">method</span></span><span class="punctuation">)</span><span class="punctuation">;</span><hr class="error-divider"><div class="listed-error"><div class="error-line">Argument of type 'string' is not assignable to parameter of type '"GET" | "POST"'.</div></div></pre></p>
<p>Because it'd be legal to assign a string like <code>"GUESS"</code> TO <code>req.method</code>, TypeScript considers this code to have an error.
You can change this inference by adding a type assertion in either location:</p>
<p><pre class="typescript-code">
<span class="keyword">const</span> <span class="identifier">req</span> <span class="operator">=</span> <span class="punctuation">{</span> <span class="identifier">url</span><span class="punctuation">:</span> <span class="stringLiteral">"https://example.com"</span><span class="punctuation">,</span> <span class="identifier">method</span><span class="punctuation">:</span> <span class="stringLiteral">"GET"</span> <span class="keyword">as</span> <span class="stringLiteral">"GET"</span> <span class="punctuation">}</span><span class="punctuation">;</span>
<span class="comment">/* or */</span>
<span class="identifier">handleRequest</span><span class="punctuation">(</span><span class="identifier">req</span><span class="punctuation">.</span><span class="identifier">url</span><span class="punctuation">,</span> <span class="identifier">req</span><span class="punctuation">.</span><span class="identifier">method</span> <span class="keyword">as</span> <span class="stringLiteral">"GET"</span><span class="punctuation">)</span><span class="punctuation">;</span><a class="playground-link" href="https://www.typescriptlang.org/play/#src=declare%20function%20handleRequest(url%3A%20string%2C%20method%3A%20%22GET%22%20%7C%20%22POST%22)%3A%20void%3B%0A%2F%2Fcut%0Aconst%20req%20%3D%20%7B%20url%3A%20%22https%3A%2F%2Fexample.com%22%2C%20method%3A%20%22GET%22%20as%20%22GET%22%20%7D%3B%0A%2F*%20or%20*%2F%0AhandleRequest(req.url%2C%20req.method%20as%20%22GET%22)%3B">Try</a></pre></p>
<p>The first change means "I intend for <code>req.method</code> to always have the <em>literal type</em> <code>"GET"</code>", preventing the possible assignment of <code>"GUESS"</code> to that field.
The second change means "I know for other reasons that <code>req.method</code> has the value <code>"GET"</code>".</p>
<h2 id="null-and-undefined"><a href="#null-and-undefined"><code>null</code> and <code>undefined</code></h2></a>
<p>JavaScript has two primitive values, <code>null</code> and <code>undefined</code>, both of which are used to signal absent or uninitialized values.</p>
<p>TypeScript has two corresponding <em>types</em> by the same names. How these types behave depends on whether you have the <code>strictNullChecks</code> option on.</p>
<h3 id="strictnullchecks-off"><a href="#strictnullchecks-off"><code>strictNullChecks</code> off</h3></a>
<p>With <code>strictNullChecks</code> <em>off</em>, values that might be <code>null</code> or <code>undefined</code> can still be accessed normally, and the values <code>null</code> and <code>undefined</code> can be assigned to a property of any type.
This is similar to how languages without null checks (e.g. C#, Java) behave.
The lack of checking for these values tends to be a major source of bugs; we always recommend people turn <code>strictNullChecks</code> on if it's practical to do so in their codebase.</p>
<h3 id="strictnullchecks-on"><a href="#strictnullchecks-on"><code>strictNullChecks</code> on</h3></a>
<p>With <code>strictNullChecks</code> <em>on</em>, when a value is <code>null</code> or <code>undefined</code>, you will need to test for those values before using methods or properties on that value.
Just like checking for <code>undefined</code> before using an optional property, we can use <em>narrowing</em> to check for values that might be <code>null</code>:</p>
<p><pre class="typescript-code"><span class="keyword">function</span> <span class="identifier">doSomething</span><span class="punctuation">(</span><span class="parameterName">x</span><span class="punctuation">:</span> <span class="keyword">string</span> <span class="punctuation">|</span> <span class="keyword">null</span><span class="punctuation">)</span> <span class="punctuation">{</span>
  <span class="keyword">if</span> <span class="punctuation">(</span><span class="identifier">x</span> <span class="operator">===</span> <span class="keyword">null</span><span class="punctuation">)</span> <span class="punctuation">{</span>
    <span class="comment">// do nothing</span>
  <span class="punctuation">}</span> <span class="keyword">else</span> <span class="punctuation">{</span>
    <span class="identifier">console</span><span class="punctuation">.</span><span class="identifier">log</span><span class="punctuation">(</span><span class="stringLiteral">"Hello, "</span> <span class="operator">+</span> <span class="identifier">x</span><span class="punctuation">.</span><span class="identifier">toUpperCase</span><span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">;</span>
  <span class="punctuation">}</span>
<span class="punctuation">}</span><a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20doSomething(x%3A%20string%20%7C%20null)%20%7B%0A%20%20if%20(x%20%3D%3D%3D%20null)%20%7B%0A%20%20%20%20%2F%2F%20do%20nothing%0A%20%20%7D%20else%20%7B%0A%20%20%20%20console.log(%22Hello%2C%20%22%20%2B%20x.toUpperCase())%3B%0A%20%20%7D%0A%7D">Try</a></pre></p>
<h3 id="non-null-operator"><a href="#non-null-operator">Non-null Assertion Operator (Postfix <code>!</code>)</h3></a>
<p>TypeScript also has a special syntax for removing <code>null</code> and <code>undefined</code> from a type without doing any explicit checking.
Writing <code>!</code> after any expression is effectively a type assertion that the value isn't <code>null</code> or <code>undefined</code>:</p>
<p><pre class="typescript-code"><span class="keyword">function</span> <span class="identifier">liveDangerously</span><span class="punctuation">(</span><span class="parameterName">x</span><span class="punctuation">?</span><span class="punctuation">:</span> <span class="keyword">number</span> <span class="punctuation">|</span> <span class="keyword">null</span><span class="punctuation">)</span> <span class="punctuation">{</span>
  <span class="comment">// No error</span>
  <span class="identifier">console</span><span class="punctuation">.</span><span class="identifier">log</span><span class="punctuation">(</span><span class="identifier">x</span><span class="punctuation">!</span><span class="punctuation">.</span><span class="identifier">toFixed</span><span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">;</span>
<span class="punctuation">}</span><a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20liveDangerously(x%3F%3A%20number%20%7C%20null)%20%7B%0A%20%20%2F%2F%20No%20error%0A%20%20console.log(x!.toFixed())%3B%0A%7D">Try</a></pre></p>
<p>Just like other type assertions, this doesn't change the runtime behavior of your code, so it's important to only use <code>!</code> when you know that the value <em>can't</em> be <code>null</code> or <code>undefined</code>.</p>
    </article>

    <script src="https://unpkg.com/popper.js@1/dist/umd/popper.min.js"></script>
    <script src="https://unpkg.com/tippy.js@4"></script>
    <script>
        tippy.setDefaults({preventOverflow: { enabled: false } });
    </script>
    </body>
    </html>